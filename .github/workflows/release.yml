name: Release
on:
  workflow_call:
    inputs:
      source:
        required: false
        default: ''
        type: string
      target:
        required: false
        default: ''
        type: string
      version:
        required: false
        default: ''
        type: string
      linux_armv7l:
        required: false
        default: false
        type: boolean
      prerelease:
        required: false
        default: true
        type: boolean
  workflow_dispatch:
    inputs:
      source:
        description: |
          SOURCE of this release's updates:
          channel, repo, tag, or channel/repo@tag
          (default: <current_repo>)
        required: false
        default: ''
        type: string
      target:
        description: |
          TARGET to publish this release to:
          channel, tag, or channel@tag
          (default: <source> if writable else <current_repo>[@source_tag])
        required: false
        default: ''
        type: string
      version:
        description: |
          VERSION: yyyy.mm.dd[.rev] or rev
          (default: auto-generated)
        required: false
        default: ''
        type: string
      linux_armv7l:
        description: Include linux_armv7l
        default: true
        type: boolean
      prerelease:
        description: Pre-release
        default: false
        type: boolean

permissions:
  contents: read

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      channel: ${{ steps.setup_variables.outputs.channel }}
      version: ${{ steps.setup_variables.outputs.version }}
      target_repo: ${{ steps.setup_variables.outputs.target_repo }}
      target_repo_token: ${{ steps.setup_variables.outputs.target_repo_token }}
      target_tag: ${{ steps.setup_variables.outputs.target_tag }}
      pypi_project: ${{ steps.setup_variables.outputs.pypi_project }}
      pypi_suffix: ${{ steps.setup_variables.outputs.pypi_suffix }}
      head_sha: ${{ steps.get_target.outputs.head_sha }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Process inputs
        id: process_inputs
        env:
          INPUTS: ${{ toJSON(inputs) }}
        shell: python
        run: |
          import json
          import os
          inputs = json.loads(os.environ['INPUTS'])
          print('::group::Inputs')
          print(json.dumps(inputs, indent=2))
          print('::endgroup::')
          outputs = {}
          for key in ('source', 'target'):
              repo, _, tag = inputs.get(key, '').partition('@')
              outputs[f'{key}_repo'] = repo
              outputs[f'{key}_tag'] = tag
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write('\n'.join(f'{key}={value}' for key, value in outputs.items()))

      - name: Setup variables
        id: setup_variables
        env:
          INPUTS: ${{ toJSON(inputs) }}
          PROCESSED: ${{ toJSON(steps.process_inputs.outputs) }}
          REPOSITORY: ${{ github.repository }}
          PUSH_VERSION_COMMIT: ${{ vars.PUSH_VERSION_COMMIT }}
          PYPI_PROJECT: ${{ vars.PYPI_PROJECT }}
          SOURCE_PYPI_PROJECT: ${{ vars[format('{0}_pypi_project', steps.process_inputs.outputs.source_repo)] }}
          SOURCE_PYPI_SUFFIX: ${{ vars[format('{0}_pypi_suffix', steps.process_inputs.outputs.source_repo)] }}
          TARGET_PYPI_PROJECT: ${{ vars[format('{0}_pypi_project', steps.process_inputs.outputs.target_repo)] }}
          TARGET_PYPI_SUFFIX: ${{ vars[format('{0}_pypi_suffix', steps.process_inputs.outputs.target_repo)] }}
          SOURCE_ARCHIVE_REPO: ${{ vars[format('{0}_archive_repo', steps.process_inputs.outputs.source_repo)] }}
          TARGET_ARCHIVE_REPO: ${{ vars[format('{0}_archive_repo', steps.process_inputs.outputs.target_repo)] }}
          HAS_SOURCE_ARCHIVE_REPO_TOKEN: ${{ toJSON(!!secrets[format('{0}_archive_repo_token', steps.process_inputs.outputs.source_repo)])}}
          HAS_TARGET_ARCHIVE_REPO_TOKEN: ${{ toJSON(!!secrets[format('{0}_archive_repo_token', steps.process_inputs.outputs.target_repo)])}}
          HAS_ARCHIVE_REPO_TOKEN: ${{ toJSON(!!secrets.ARCHIVE_REPO_TOKEN) }}
        shell: python
        run: |
          import datetime
          import json
          import os
          import subprocess
          import sys
          
          REPOSITORY = os.environ['REPOSITORY']
          inputs = json.loads(os.environ['INPUTS'])
          processed = json.loads(os.environ['PROCESSED'])
          
          source_channel = None
          does_not_have_needed_token = False
          target_repo_token = None
          pypi_project = None
          pypi_suffix = None
          
          source_repo = processed['source_repo']
          source_tag = processed['source_tag']
          if source_repo == 'stable':
              source_repo = 'yt-dlp/yt-dlp'
          elif not source_repo:
              source_repo = REPOSITORY
          elif os.environ['SOURCE_ARCHIVE_REPO']:
              source_channel = os.environ['SOURCE_ARCHIVE_REPO']
          elif not source_tag and '/' not in source_repo:
              source_tag = source_repo
              source_repo = REPOSITORY
          
          resolved_source = source_repo
          if source_tag:
              resolved_source = f'{resolved_source}@{source_tag}'
          elif source_repo == 'yt-dlp/yt-dlp':
              resolved_source = 'stable'
          
          if inputs['prerelease'] or not os.environ['PUSH_VERSION_COMMIT']:
              revision = datetime.datetime.now(tz=datetime.timezone.utc).strftime('%H%M%S')
          else:
              revision = ''
          
          version = json.loads(subprocess.run((
              'python', 'devscripts/update-version.py',
              '--json',
              '-c', resolved_source,
              '-r', REPOSITORY,
              inputs.get('version') or revision,
          ), stdout=subprocess.PIPE, stderr=subprocess.DEVNULL).stdout)['version']
          
          target_repo = processed['target_repo']
          target_tag = processed['target_tag']
          if target_repo:
              if not target_tag:
                  if os.environ['TARGET_ARCHIVE_REPO']:
                      target_tag = source_tag or version
                  else:
                      target_tag = target_repo
                      target_repo = REPOSITORY
              if target_repo != REPOSITORY:
                  target_repo = os.environ['TARGET_ARCHIVE_REPO']
                  target_repo_token = f'{processed["target_repo"].upper()}_ARCHIVE_REPO_TOKEN'
                  if not json.loads(os.environ['HAS_TARGET_ARCHIVE_REPO_TOKEN']):
                      does_not_have_needed_token = True
                  pypi_project = os.environ['TARGET_PYPI_PROJECT']
                  pypi_suffix = os.environ['TARGET_PYPI_SUFFIX']
          else:
              target_tag = source_tag or version
              if source_channel:
                  target_repo = source_channel
                  target_repo_token = f'{processed["source_repo"].upper()}_ARCHIVE_REPO_TOKEN'
                  if not json.loads(os.environ['HAS_SOURCE_ARCHIVE_REPO_TOKEN']):
                      does_not_have_needed_token = True
                  pypi_project = os.environ['SOURCE_PYPI_PROJECT']
                  pypi_suffix = os.environ['SOURCE_PYPI_SUFFIX']
              else:
                  target_repo = REPOSITORY
          
          if does_not_have_needed_token:
              if not json.loads(os.environ['HAS_ARCHIVE_REPO_TOKEN']):
                  print('::error::Repository access secret {target_repo_token} not found')
                  sys.exit(1)
              target_repo_token = 'ARCHIVE_REPO_TOKEN'
          
          if target_repo == REPOSITORY and inputs['prerelease']:
              pypi_project = os.environ['PYPI_PROJECT'] or None
          
          outputs = {
              'channel': resolved_source,
              'version': version,
              'target_repo': target_repo,
              'target_repo_token': target_repo_token,
              'target_tag': target_tag,
              'pypi_project': pypi_project,
              'pypi_suffix': pypi_suffix,
          }
          print('::group::Output variables')
          print(json.dumps(outputs, indent=2))
          print('::endgroup::')
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write('\n'.join(f'{key}={value or ""}' for key, value in outputs.items()))

      - name: Process inputs (old)
        id: process_inputs_old
        run: |
          cat << EOF
          ::group::Inputs
          prerelease=${{ inputs.prerelease }}
          source=${{ inputs.source }}
          target=${{ inputs.target }}
          version=${{ inputs.version }}
          ::endgroup::
          EOF
          IFS='@' read -r source_repo source_tag <<<"${{ inputs.source }}"
          IFS='@' read -r target_repo target_tag <<<"${{ inputs.target }}"
          cat << EOF >> "$GITHUB_OUTPUT"
          source_repo=${source_repo}
          source_tag=${source_tag}
          target_repo=${target_repo}
          target_tag=${target_tag}
          EOF

      - name: Setup variables (old)
        id: setup_variables_old
        env:
          source_repo: ${{ steps.process_inputs_old.outputs.source_repo }}
          source_tag: ${{ steps.process_inputs_old.outputs.source_tag }}
          target_repo: ${{ steps.process_inputs_old.outputs.target_repo }}
          target_tag: ${{ steps.process_inputs_old.outputs.target_tag }}
        run: |
          # unholy bash monstrosity (sincere apologies)
          fallback_token () {
            if ${{ !secrets.ARCHIVE_REPO_TOKEN }}; then
              echo "::error::Repository access secret ${target_repo_token^^} not found"
              exit 1
            fi
            target_repo_token=ARCHIVE_REPO_TOKEN
            return 0
          }

          source_is_channel=0
          [[ "${source_repo}" == 'stable' ]] && source_repo='yt-dlp/yt-dlp'
          if [[ -z "${source_repo}" ]]; then
            source_repo='${{ github.repository }}'
          elif [[ '${{ vars[format('{0}_archive_repo', env.source_repo)] }}' ]]; then
            source_is_channel=1
            source_channel='${{ vars[format('{0}_archive_repo', env.source_repo)] }}'
          elif [[ -z "${source_tag}" && "${source_repo}" != */* ]]; then
            source_tag="${source_repo}"
            source_repo='${{ github.repository }}'
          fi
          resolved_source="${source_repo}"
          if [[ "${source_tag}" ]]; then
            resolved_source="${resolved_source}@${source_tag}"
          elif [[ "${source_repo}" == 'yt-dlp/yt-dlp' ]]; then
            resolved_source='stable'
          fi

          revision="${{ (inputs.prerelease || !vars.PUSH_VERSION_COMMIT) && '$(date -u +"%H%M%S")' || '' }}"
          version="$(
            python devscripts/update-version.py \
            -c "${resolved_source}" -r "${{ github.repository }}" ${{ inputs.version || '$revision' }} | \
            grep -Po "version=\K\d+\.\d+\.\d+(\.\d+)?")"

          if [[ "${target_repo}" ]]; then
            if [[ -z "${target_tag}" ]]; then
              if [[ '${{ vars[format('{0}_archive_repo', env.target_repo)] }}' ]]; then
                target_tag="${source_tag:-${version}}"
              else
                target_tag="${target_repo}"
                target_repo='${{ github.repository }}'
              fi
            fi
            if [[ "${target_repo}" != '${{ github.repository}}' ]]; then
              target_repo='${{ vars[format('{0}_archive_repo', env.target_repo)] }}'
              target_repo_token='${{ env.target_repo }}_archive_repo_token'
              ${{ !!secrets[format('{0}_archive_repo_token', env.target_repo)] }} || fallback_token
              pypi_project='${{ vars[format('{0}_pypi_project', env.target_repo)] }}'
              pypi_suffix='${{ vars[format('{0}_pypi_suffix', env.target_repo)] }}'
            fi
          else
            target_tag="${source_tag:-${version}}"
            if ((source_is_channel)); then
              target_repo="${source_channel}"
              target_repo_token='${{ env.source_repo }}_archive_repo_token'
              ${{ !!secrets[format('{0}_archive_repo_token', env.source_repo)] }} || fallback_token
              pypi_project='${{ vars[format('{0}_pypi_project', env.source_repo)] }}'
              pypi_suffix='${{ vars[format('{0}_pypi_suffix', env.source_repo)] }}'
            else
              target_repo='${{ github.repository }}'
            fi
          fi

          if [[ "${target_repo}" == '${{ github.repository }}' ]] && ${{ !inputs.prerelease }}; then
            pypi_project='${{ vars.PYPI_PROJECT }}'
          fi

          echo "::group::Output variables"
          cat << EOF | tee -a "$GITHUB_OUTPUT"
          channel=${resolved_source}
          version=${version}
          target_repo=${target_repo}
          target_repo_token=${target_repo_token}
          target_tag=${target_tag}
          pypi_project=${pypi_project}
          pypi_suffix=${pypi_suffix}
          EOF
          echo "::endgroup::"
